## version 1 details

predictors: refinedpreds_v1.rds

results object:

results_save <- data.frame(
  dev_value = rep(dev, length(pvals)),
  p_cutoff = pvals,
  iterations = integer(length(pvals)),
  final_roi = I(vector("list", length(pvals))),  ## I() keeps as a list-column
  final_features = I(vector("list", length(pvals)))
)

iteration procedure:

run_iteration <- function(target_dev, p_cutoff, ROI, max_iterations=100) {
  iterations <- 1
  length_roi <- length(ROI)
  current_roi <- ROI
  prev_roi <- NULL
  
  while(iterations < max_iterations) {
    # Early termination checks
    roi_sum <- sum(current_roi)
    if (roi_sum %in% c(0, 1, length_roi - 1, length_roi)) break ## terminate if we'll get glmnet errors
    if (!is.null(prev_roi) && identical(prev_roi, current_roi)) break ## or if we get convergence
    
    # Fit model
    dev_model <- glmnet(x = PREDS, y = current_roi, family = "binomial", 
                        alpha = 1, standardize = FALSE)  # Consider if you need standardization
    
    # Find lambda (vectorized)
    lambda_id <- which.min(abs(dev_model$dev.ratio * 100 - target_dev))
    
    # Predict (could reuse dev_model object without refitting)
    dev_predictions <- predict(dev_model, newx = PREDS, 
                               s = dev_model$lambda[lambda_id], 
                               type = "response")
    
    prev_roi <- current_roi
    current_roi <- as.integer(dev_predictions > p_cutoff)
    iterations <- iterations + 1
  }
  
  coeffs <- coef(dev_model,s=dev_model$lambda[lambda_id])
  vars <- rownames(coeffs)[which(coeffs != 0)]
  vars <- vars[vars != "(Intercept)"]
  
  list(iterations = iterations, 
       init_roi = ROI, 
       final_features = vars,
       final_roi = current_roi)
}